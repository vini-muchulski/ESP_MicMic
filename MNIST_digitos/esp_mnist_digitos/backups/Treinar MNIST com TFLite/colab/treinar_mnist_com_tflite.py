# -*- coding: utf-8 -*-
"""Treinar MNIST com TFLite

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w7eHPiC3SlLR3J9L5cNLhJ2TeIM-skpo
"""

import tensorflow as tf
import numpy as np

# 1. Dados ────────────────────────────────────────────────────────────────
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0          # normaliza
x_train = x_train[..., None].astype("float32")             # (28,28)→(28,28,1)
x_test  = x_test[..., None].astype("float32")

import matplotlib.pyplot as plt
import random

# Supondo que x_train e y_train já existam (já normalizados como float32 e com shape (28,28,1))
# 1. Escolhe um índice aleatório
idx = random.randint(0, x_train.shape[0] - 1)

# 2. Recupera a imagem e o rótulo
img = x_train[idx].squeeze()      # squeeze() transforma (28,28,1) em (28,28)
label = y_train[idx]

# 3. Plota
plt.figure(figsize=(4,4))
plt.imshow(img, cmap='gray')
plt.title(f"Rótulo: {label}")
plt.axis('off')   # desliga os eixos para ficar mais limpo
plt.show()

"""# Treino Modelo"""

model = tf.keras.Sequential([
    tf.keras.layers.Input((28, 28, 1)),
    tf.keras.layers.Conv2D(32, 3, activation="relu"),
    tf.keras.layers.MaxPool2D(),
    tf.keras.layers.Conv2D(64, 3, activation="relu"),
    tf.keras.layers.MaxPool2D(),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation="relu"),
    tf.keras.layers.Dense(10, activation="softmax")
])
model.compile(optimizer="adam",
              loss="sparse_categorical_crossentropy",
              metrics=["accuracy"])

model.fit(x_train, y_train,
          epochs=5, batch_size=128,
          validation_split=0.1)

loss, acc = model.evaluate(x_test, y_test, verbose=0)
print(f"Acurácia de teste: {acc:.4f}")

"""# Conversão p/ TensorFlow Lite"""

converter = tf.lite.TFLiteConverter.from_keras_model(model)

converter.optimizations = [tf.lite.Optimize.DEFAULT]

tflite_model = converter.convert()
open("mnist_cnn.tflite", "wb").write(tflite_model)
print("Modelo salvo em mnist_cnn.tflite")

# índice da imagem no batch de teste
index = 8

# prepara o sample e recupera o rótulo verdadeiro
sample = x_test[index : index+1]      # shape (1, 28, 28, 1)
true_label = y_test[index]            # rótulo “verdadeiro”

print("Classe verdadeira:", true_label)

# faz inference TFLite
interpreter = tf.lite.Interpreter(model_path="mnist_cnn.tflite")
#interpreter = tf.lite.Interpreter(model_path="mnist_cnn_int8.tflite")

interpreter.allocate_tensors()

input_idx  = interpreter.get_input_details()[0]["index"]
output_idx = interpreter.get_output_details()[0]["index"]

interpreter.set_tensor(input_idx, sample)
interpreter.invoke()
pred = interpreter.get_tensor(output_idx)

print("Dígito previsto:", np.argmax(pred))